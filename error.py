import pandas as pd
import os
import re
from datetime import datetime

def errorchex(df):
    #Double make sure ERROR column is initialised
    if "ERROR" not in df.columns:
        df["ERROR"] = ""


    #Concatenate Address columns if they exist and the single ADDRESS column does not
    if "ADDRESS" not in df:
        
        if {"ADDRESS1","ADDRESS2","ADDRESS3","ADDRESS4"}.issubset(df.columns):
            print(f"{datetime.now()}: Concatenating 4 Address Columns")
            df['ADDRESS'] = df['ADDRESS1'].astype(str) + '~' + df['ADDRESS2'].astype(str) + '~' + df['ADDRESS3'].astype(str) + '~' + df['ADDRESS4'].astype(str) #df[['ADDRESS1', 'ADDRESS2', 'ADDRESS3', 'ADDRESS4']].agg('~'.join, axis=1)
        elif {"ADDRESS1","ADDRESS2","ADDRESS3"}.issubset(df.columns):
            print(f"{datetime.now()}: Concatenating 3 Address Columns")
            df['ADDRESS'] = df['ADDRESS1'].astype(str) + '~' + df['ADDRESS2'].astype(str) + '~' + df['ADDRESS3'].astype(str) #df[['ADDRESS1', 'ADDRESS2','ADDRESS3']].agg('~'.join, axis=1)
        elif {"ADDRESS1","ADDRESS2"}.issubset(df.columns):
            print(f"{datetime.now()}: Concatenating 2 Address Columns")
            df['ADDRESS'] = df['ADDRESS1'].astype(str) + '~' + df['ADDRESS2'].astype(str) #df[['ADDRESS1','ADDRESS2']].agg('~'.join, axis=1)
        elif "ADDRESS1" in df:
            df['ADDRESS'] = df['ADDRESS1']
        #remove any nans generated by the above
        if "ADDRESS" in df:
            df["ADDRESS"] = df["ADDRESS"].str.replace(r"~nan","",regex = True)

        
    
    #same for delivery address
    if "DELADDRESS" not in df:
        if {"DELADDRESS1","DELADDRESS2","DELADDRESS3","DELADDRESS4"}.issubset(df.columns):
            print(f"{datetime.now()}: Concatenating 4 DELADDRESS Columns")
            df['DELADDRESS'] = df['DELADDRESS1'].astype(str) + '~' + df['DELADDRESS2'].astype(str) + '~' + df['DELADDRESS3'].astype(str) + '~' + df['DELADDRESS4'].astype(str) #df[['DELADDRESS1', 'ADDRESS2', 'ADDRESS3', 'ADDRESS4']].agg('~'.join, axis=1)
        elif {"DELADDRESS1","DELADDRESS2","DELADDRESS3"}.issubset(df.columns):
            print(f"{datetime.now()}: Concatenating 3 DELADDRESS Columns")
            df['DELADDRESS'] = df['DELADDRESS1'].astype(str) + '~' + df['DELADDRESS2'].astype(str) + '~' + df['DELADDRESS3'].astype(str) #df[['ADDRESS1', 'ADDRESS2','ADDRESS3']].agg('~'.join, axis=1)
        elif {"DELADDRESS1","DELADDRESS2"}.issubset(df.columns):
            print(f"{datetime.now()}: Concatenating 2 DELADDRESS Columns")
            df['DELADDRESS'] = df['DELADDRESS1'].astype(str) + '~' + df['DELADDRESS2'].astype(str) #df[['ADDRESS1','ADDRESS2']].agg('~'.join, axis=1)
        elif "DELADDRESS1" in df:
            df['DELADDRESS'] = df['DELADDRESS1']
        #remove any nans generated by the above
        if "DELADDRESS" in df:
            df["DELADDRESS"] = df["DELADDRESS"].str.replace(r"~nan","",regex = True)
    
    #List required columns
    required_columns = ["REF_NO", "PART", "QTY", "FIRSTNAME", "SURNAME", "ADDRESS", "CITY", "POSTCODE"]
    
    #confirm required columns exist in dataframe
    for col in required_columns:
    #if not, add error.
        if col not in df.columns:
            add_error(df, f"{col} column does not exist")
    
    #if any errors at this point, return to main - NO ROW CHECKS IF COLUMNS MISSING
    if df["ERROR"].any():
        return df
    
    #Perform checks on individual rows
    df = df.apply(rowchex, axis = 1)
    df = df.apply(error_none, axis = 1)
    return df

def rowchex(row):
    required_columns = ["REF_NO", "PART", "QTY", "FIRSTNAME", "SURNAME", "ADDRESS", "CITY", "POSTCODE"]
    errors = []
    for col in required_columns:
        if row[col] == "" or pd.isna(row[col]):
            errors.append(f"{col} column empty")
    #Order number length check
    if len(str(row["REF_NO"])) > 12:
        errors.append("Ref_No too long (>12 chars)")
    
    # Order total numeric check
    if "ORDTOTAL" in row.index and not pd.isna(row["ORDTOTAL"]):
        try:
            row["ORDTOTAL"] = float(row["ORDTOTAL"])  # Try direct conversion first
        except (ValueError, TypeError):
            row["ORDTOTAL"] = re.sub(r'[^0-9.]', '', str(row["ORDTOTAL"]))
            if pd.isna(pd.to_numeric(row["ORDTOTAL"], errors='coerce')):
                errors.append("Order Total not a number")
            else:
                row["ORDTOTAL"] = float(row["ORDTOTAL"])
    
    # Unit price numeric check
    if "UNITPRICE" in row.index and not pd.isna(row["UNITPRICE"]):
        try:
            row["UNITPRICE"] = float(row["UNITPRICE"])
        except (ValueError, TypeError):
            row["UNITPRICE"] = re.sub(r'[^0-9.]', '', str(row["UNITPRICE"]))
            if pd.isna(pd.to_numeric(row["UNITPRICE"], errors='coerce')):
                errors.append("Unit Price not a number")
            else:
                row["UNITPRICE"] = float(row["UNITPRICE"])
    
    # Delivery charge numeric check
    if "DELCHG" in row.index and not pd.isna(row["DELCHG"]):
        try:
            row["DELCHG"] = float(row["DELCHG"])
        except (ValueError, TypeError):
            row["DELCHG"] = re.sub(r'[^0-9.]', '', str(row["DELCHG"]))
            if pd.isna(pd.to_numeric(row["DELCHG"], errors='coerce')):
                errors.append("Delivery Charge not a number")
            else:
                row["DELCHG"] = float(row["DELCHG"])
    
    #Qty numeric check
    if pd.isna(pd.to_numeric(row["QTY"], errors='coerce')):
        errors.append("Qty not a number or blank")
    else:
        row["QTY"] = float(re.sub(r'[^0-9.]','',str(round(row["QTY"]))))
    #MORE CHEX TO COME
    #Concat the errors into the error column using | as the join.
    if errors:
        row["ERROR"] = row["ERROR"] + "|" + "|".join(errors) if row["ERROR"] else "|".join(errors)
    return row

def add_error(df, err):
    df["ERROR"] = df["ERROR"].apply(lambda x: x + "|" + err if x else err)

def row_add_error(row,err):
    row["ERROR"] = row["ERROR"] + "|" + err if row["ERROR"] else err

def error_export(df,path,file,suffix = ".csv"):
    ind = file.find(suffix)
    errname = file[:ind] + "error" + file[ind:]
    errpath = path + "/errors"
    os.makedirs(errpath,exist_ok=True)
    df.to_csv(errpath + "/" + errname,index = False, header = True)

def error_none(row):
    if row["ERROR"] == "":
        row["ERROR"] = None
    return row

# def inj_chex(row):
#     concerned = ["DROP TABLE","INSERT","DELETE FROM"]
#     con = []
#     for c in concerned:
#         con.append(row.str.contains(pat = c, case = False))
#     if any(con) == True:
#         if row["ERROR"] == "":
#             row["ERROR"] = "POTENTIAL INJECTION ATTACK - FILE REJECTED"
#         else:
#             row["ERROR"] = row["ERROR"] + "|POTENTIAL INJECTION ATTACK - FILE REJECTED"
#     return row
